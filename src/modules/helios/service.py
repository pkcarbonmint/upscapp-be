from __future__ import annotations

from datetime import date, timedelta
from typing import List, Dict

from fastapi_async_sqlalchemy import db

from src.modules.teaching.schemas import (
	StudyPlanCreate as BEStudyPlanCreate,
	PlanTaskCreate,
	TASK_STATUS,
	TASK_TYPE,
	SubjectArea,
	UserInfo,
)
from src.base.service import BaseCRUD
from src.modules.teaching.models import StudyPlan, PlanTask

from .adaptive_client import get_helios_adaptive_client
from .data_mapper import HeliosDataMapper

from .schemas import IntakeSchema, GeneratePlanFromWizardRequest
from .config import get_practice_link, get_test_link

# CMS utilities to resolve subjects/topics for weekly test planning
from src.external.cms.service import (
    get_mains_papers,
    get_mains_subjects,
    get_topics_ids,
)


class HeliosIntegrationService:
	"""Adapter that materializes Helios plans into backend data models.

	This service is responsible for turning the pure planning output from
	the Haskell Helios HTTP server into database entities understood by the `teaching` domain.
	"""

	def __init__(self) -> None:
		self.studyplan_crud = BaseCRUD(model=StudyPlan)
		self.plantask_crud = BaseCRUD(model=PlanTask)
		self.data_mapper = HeliosDataMapper()

	# --- CMS Service Interface Methods ---

	async def resolve_subject_names_to_ids(self, subject_names: list[str]) -> dict[str, int]:
		"""Best-effort mapping from engine macro subjects â†’ CMS subject IDs."""
		papers = await get_mains_papers()
		paper_ids = papers.get("ids", [])
		mains_subjects = await get_mains_subjects(paper_ids=paper_ids)
		name_to_id: dict[str, int] = {s["name"].lower(): s["id"] for s in mains_subjects}
		resolved: dict[str, int] = {}
		for macro in subject_names:
			ml = macro.lower()
			match_id: int | None = None
			for subj_name_l, subj_id in name_to_id.items():
				if ml in subj_name_l:
					match_id = subj_id
					break
			if match_id is not None:
				resolved[macro] = match_id
		return resolved

	async def get_topics_for_subjects(self, subject_ids: list[int]) -> dict[int, list[str]]:
		"""Fetch topic names for each CMS subject ID."""
		subj_to_topics: dict[int, list[str]] = {}
		for sid in subject_ids:
			topic_names = await get_topics_ids(subject_id=sid) # Assuming this now returns names
			subj_to_topics[sid] = topic_names
		return subj_to_topics

	async def health_check(self) -> bool:
		"""Check if the Haskell Helios engine is available."""
		client = await get_helios_adaptive_client()
		return await client.health_check()

	async def generate_plan_from_wizard(self, req: GeneratePlanFromWizardRequest) -> int:
		"""Accept wizard payload, generate plan via Haskell HTTP server, and persist it."""
		try:
			# Convert wizard data to Haskell format
			haskell_wizard_data = self.data_mapper.python_wizard_to_haskell_format(req.wizard)
			
			# Get Haskell adaptive client (FFI or HTTP)
			client = await get_helios_adaptive_client()
			
			# Generate plan using Haskell engine
			haskell_plan = await client.generate_plan(haskell_wizard_data)
			
			# Create study plan in database
			creator = UserInfo(id=req.created_by_id, name=req.created_by_name)
			sp = await self.studyplan_crud.create(
				db=db.session,
				object=BEStudyPlanCreate(
					name=haskell_plan.get("title", "Helios Generated Plan"),
					offering_id=req.offering_id,
					batch_id=None,
					product_id=req.product_id,
					created_by_id=req.created_by_id,
					created_by=creator,
					remarks="Generated by Helios Haskell Engine",
					status="DRAFT",
				),
			)
			
			# Convert Haskell plan to Python tasks
			tasks = self.data_mapper.haskell_plan_to_python_tasks(
				haskell_plan, sp.id, req.created_by_id, req.created_by_name
			)
			
			# Bulk create tasks
			if tasks:
				await self.plantask_crud.bulk_create(db=db.session, objects=tasks)
			
			return sp.id
			
		except Exception as e:
			raise Exception(f"Failed to generate plan using Haskell engine: {e}")

	async def generate_plan(
		self,
		*,
		user_id: int,
		product_id: int,
		offering_id: int,
		created_by_id: int,
		created_by_name: str,
		intake: IntakeSchema,
	) -> int:
		"""Legacy method - converts IntakeSchema to wizard format and uses Haskell engine."""
		# Convert IntakeSchema to a basic wizard format
		wizard_data = {
			"personal_details": {
				"full_name": f"User {user_id}",
				"email": f"user{user_id}@example.com",
				"phone_number": "",
				"present_location": "",
				"current_status": "Student",
				"graduation_stream": "",
				"college_university": "",
				"year_of_passing": 2024
			},
			"preparation_background": {
				"preparing_since": "1 year",
				"target_year": "2025",
				"number_of_attempts": "1",
				"highest_stage_per_attempt": "Prelims",
				"last_attempt_gs_prelims_score": 0,
				"last_attempt_csat_score": 0,
				"wrote_mains_in_last_attempt": "No",
				"mains_paper_marks": ""
			},
			"subject_confidence": {k: v.value for k, v in intake.assessments.items()},
			"study_strategy": {
				"weekly_study_hours": f"{intake.weekly_study_hours} hours",
				"study_approach": intake.study_pacing.value.replace("_", " ").title(),
				"revision_strategy": "Regular",
				"test_frequency": "Weekly"
			}
		}
		
		# Create a mock wizard request
		from .schemas import GeneratePlanFromWizardRequest
		wizard_req = GeneratePlanFromWizardRequest(
			user_id=user_id,
			product_id=product_id,
			offering_id=offering_id,
			created_by_id=created_by_id,
			created_by_name=created_by_name,
			wizard=wizard_data
		)
		
		return await self.generate_plan_from_wizard(wizard_req)

	async def get_study_plan_for_export(self, studyplan_id: int) -> StudyPlanSchema:
		"""
		Retrieve study plan data formatted for document export.
		
		Args:
			studyplan_id: ID of the study plan to export
			
		Returns:
			StudyPlanSchema object with plan data and cycle information
			
		Raises:
			Exception: If study plan not found or data retrieval fails
		"""
		try:
			# Get study plan from database
			study_plan = await self.studyplan_crud.get(studyplan_id)
			if not study_plan:
				return None
			
			# Get associated plan tasks with cycle information
			plan_tasks = await self.plantask_crud.get_multi_by_field("studyplan_id", studyplan_id)
			
			# Group tasks by blocks and extract cycle information
			blocks_data = self._group_tasks_into_blocks(plan_tasks)
			
			# Create StudyPlanSchema object
			from .schemas import StudyPlanSchema, BlockSchema
			
			blocks = []
			for block_data in blocks_data:
				block_schema = BlockSchema(
					block_id=block_data["block_id"],
					title=block_data["title"],
					cycle_id=block_data.get("cycle_id"),
					cycle_type=block_data.get("cycle_type"),
					cycle_order=block_data.get("cycle_order"),
					cycle_name=block_data.get("cycle_name"),
					subjects=block_data["subjects"],
					duration_weeks=block_data["duration_weeks"],
					weekly_plan=block_data["weekly_plan"],
					resources=block_data["resources"]
				)
				blocks.append(block_schema)
			
			study_plan_schema = StudyPlanSchema(
				study_plan_id=str(study_plan.id),
				user_id=str(study_plan.user_id),
				title=study_plan.title or f"Study Plan {study_plan.id}",
				blocks=blocks,
				curated_resources=study_plan.curated_resources or {},
				effective_season_context=getattr(study_plan, 'effective_season_context', None),
				created_for_target_year=getattr(study_plan, 'created_for_target_year', None)
			)
			
			return study_plan_schema
			
		except Exception as e:
			raise Exception(f"Error retrieving study plan for export: {e}")
	
	def _group_tasks_into_blocks(self, plan_tasks: List[PlanTask]) -> List[Dict]:
		"""
		Group plan tasks into blocks with cycle information.
		
		Args:
			plan_tasks: List of PlanTask objects
			
		Returns:
			List of block dictionaries with aggregated task data
		"""
		blocks_dict = {}
		
		for task in plan_tasks:
			# Use cycle_id as block identifier, or create a default block
			block_id = getattr(task, 'cycle_id', None) or f"block_{task.id // 100}"
			
			if block_id not in blocks_dict:
				blocks_dict[block_id] = {
					"block_id": block_id,
					"title": getattr(task, 'cycle_name', None) or f"Study Block {len(blocks_dict) + 1}",
					"cycle_id": getattr(task, 'cycle_id', None),
					"cycle_type": getattr(task, 'cycle_type', None),
					"cycle_order": getattr(task, 'cycle_order', None),
					"cycle_name": getattr(task, 'cycle_name', None),
					"subjects": set(),
					"duration_weeks": 0,
					"weekly_plan": {"daily_plans": []},
					"resources": {},
					"tasks": []
				}
			
			# Add task data to block
			block = blocks_dict[block_id]
			block["tasks"].append(task)
			block["subjects"].update(task.subjects or [])
		
		# Convert to final format
		result_blocks = []
		for block_data in blocks_dict.values():
			# Calculate duration based on task dates
			if block_data["tasks"]:
				dates = [task.planned_completion_date for task in block_data["tasks"] if task.planned_completion_date]
				if dates:
					min_date = min(dates)
					max_date = max(dates)
					duration_days = (max_date - min_date).days + 1
					block_data["duration_weeks"] = max(1, duration_days // 7)
			
			# Convert subjects set to list
			block_data["subjects"] = list(block_data["subjects"])
			
			# Remove tasks from final output (not needed for document generation)
			del block_data["tasks"]
			
			result_blocks.append(block_data)
		
		# Sort blocks by cycle order if available
		result_blocks.sort(key=lambda b: (b.get("cycle_order") or 999, b["block_id"]))
		
		return result_blocks
